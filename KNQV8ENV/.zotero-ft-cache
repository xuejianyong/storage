arXiv:1903.00374v4 [cs.LG] 19 Feb 2020

Published as a conference paper at ICLR 2020
MODEL BASED REINFORCEMENT LEARNING FOR ATARI
Łukasz Kaiser1,∗, Mohammad Babaeizadeh1,∗, Piotr Miłos2,3,∗, Błaz˙ej Osin´ ski2,4, ∗ Roy H. Campbell5, Konrad Czechowski4, Dumitru Erhan1, Chelsea Finn1,6, Piotr Kozakowski4, Sergey Levine1, Afroz Mohiuddin1, Ryan Sepassi1, George Tucker1, Henryk Michalewski4
1Google Brain, 2deepsense.ai, 3Institute of Mathematics of the Polish Academy of Sciences, 4Faculty of Mathematics, Informatics and Mechanics, University of Warsaw, 5University of Illinois at Urbana–Champaign, 6Stanford University
ABSTRACT
Model-free reinforcement learning (RL) can be used to learn effective policies for complex tasks, such as Atari games, even from image observations. However, this typically requires very large amounts of interaction – substantially more, in fact, than a human would need to learn the same games. How can people learn so quickly? Part of the answer may be that people can learn how the game works and predict which actions will lead to desirable outcomes. In this paper, we explore how video prediction models can similarly enable agents to solve Atari games with fewer interactions than model-free methods. We describe Simulated Policy Learning (SimPLe), a complete model-based deep RL algorithm based on video prediction models and present a comparison of several model architectures, including a novel architecture that yields the best results in our setting. Our experiments evaluate SimPLe on a range of Atari games in low data regime of 100k interactions between the agent and the environment, which corresponds to two hours of real-time play. In most games SimPLe outperforms state-of-the-art model-free algorithms, in some games by over an order of magnitude.
1 INTRODUCTION
Human players can learn to play Atari games in minutes (Tsividis et al., 2017). However, some of the best model-free reinforcement learning algorithms require tens or hundreds of millions of time steps – the equivalent of several weeks of training in real time. How is it that humans can learn these games so much faster? Perhaps part of the puzzle is that humans possess an intuitive understanding of the physical processes that are represented in the game: we know that planes can ﬂy, balls can roll, and bullets can destroy aliens. We can therefore predict the outcomes of our actions. In this paper, we explore how learned video models can enable learning in the Atari Learning Environment (ALE) benchmark Bellemare et al. (2015); Machado et al. (2018) with a budget restricted to 100K time steps – roughly to two hours of a play time.
Although prior works have proposed training predictive models for next-frame, future-frame, as well as combined future-frame and reward predictions in Atari games (Oh et al. (2015); Chiappa et al. (2017); Leibfried et al. (2016)), no prior work has successfully demonstrated model-based control via predictive models that achieve competitive results with model-free RL. Indeed, in a recent survey (Section 7.2 in Machado et al. (2018)) this was formulated as the following challenge: “So far, there has been no clear demonstration of successful planning with a learned model in the ALE”.
Using models of environments, or informally giving the agent ability to predict its future, has a fundamental appeal for reinforcement learning. The spectrum of possible applications is vast, including learning policies from the model (Watter et al., 2015; Finn et al., 2016; Finn & Levine, 2017; Ebert et al., 2017; Hafner et al., 2019; Piergiovanni et al., 2018; Rybkin et al., 2018; Sutton & Barto,
∗Equal contribution, authors listed in random order. BO performed the work partially during an internship at Google Brain. Correspondence to: b.osinski@mimuw.edu.pl
1

Published as a conference paper at ICLR 2020
Figure 1: Main loop of SimPLe. 1) the agent starts interacting with the real environment following the latest policy (initialized to random). 2) the collected observations will be used to train (update) the current world model. 3) the agent updates the policy by acting inside the world model. The new policy will be evaluated to measure the performance of the agent as well as collecting more data (back to 1). Note that world model training is self-supervised for the observed states and supervised for the reward.
2017, Chapter 8), capturing important details of the scene (Ha & Schmidhuber, 2018), encouraging exploration (Oh et al., 2015), creating intrinsic motivation (Schmidhuber, 2010) or counterfactual reasoning (Buesing et al., 2019). One of the exciting beneﬁts of model-based learning is the promise to substantially improve sample efﬁciency of deep reinforcement learning (see Chapter 8 in Sutton & Barto (2017)). Our work advances the state-of-the-art in model-based reinforcement learning by introducing a system that, to our knowledge, is the ﬁrst to successfully handle a variety of challenging games in the ALE benchmark. To that end, we experiment with several stochastic video prediction techniques, including a novel model based on discrete latent variables. We present an approach, called Simulated Policy Learning (SimPLe), that utilizes these video prediction techniques and trains a policy to play the game within the learned model. With several iterations of dataset aggregation, where the policy is deployed to collect more data in the original game, we learn a policy that, for many games, successfully plays the game in the real environment (see videos on the project webpage https://goo.gl/itykP8). In our empirical evaluation, we ﬁnd that SimPLe is signiﬁcantly more sample-efﬁcient than a highly tuned version of the state-of-the-art Rainbow algorithm (Hessel et al., 2018) on almost all games. In particular, in low data regime of 100k samples, on more than half of the games, our method achieves a score which Rainbow requires at least twice as many samples. In the best case of Freeway, our method is more than 10x more sample-efﬁcient, see Figure 3. Since the publication of the ﬁrst preprint of this work, it has been shown in van Hasselt et al. (2019); Kielak (2020) that Rainbow can be tuned to have better results in low data regime. The results are on a par with SimPLe – both of the model-free methods are better in 13 games, while SimPLe is better in the other 13 out of the total 26 games tested (note that in Section 4.2 van Hasselt et al. (2019) compares with the results of our ﬁrst preprint, later improved).
2 RELATED WORK
Atari games gained prominence as a benchmark for reinforcement learning with the introduction of the Arcade Learning Environment (ALE) Bellemare et al. (2015). The combination of reinforcement learning and deep models then enabled RL algorithms to learn to play Atari games directly from images of the game screen, using variants of the DQN algorithm (Mnih et al., 2013; 2015; Hessel et al., 2018) and actor-critic algorithms (Mnih et al., 2016; Schulman et al., 2017; Babaeizadeh et al., 2017b; Wu et al., 2017; Espeholt et al., 2018). The most successful methods in this domain remain model-free algorithms (Hessel et al., 2018; Espeholt et al., 2018). Although the sample complexity of these methods has substantially improved recently, it remains far higher than the amount of experience required for human players to learn each game (Tsividis et al., 2017). In this work, we aim to learn Atari games with a budget of just 100K agent steps (400K frames), corresponding to about two hours of play time. Prior methods are generally not evaluated in this regime, and we therefore optimized Rainbow (Hessel et al., 2018) for optimal performance on 1M steps, see Appendix E for details.
2

Published as a conference paper at ICLR 2020
Oh et al. (2015) and Chiappa et al. (2017) show that learning predictive models of Atari 2600 environments is possible using appropriately chosen deep learning architectures. Impressively, in some cases the predictions maintain low L2 error over timespans of hundreds of steps. As learned simulators of Atari environments are core ingredients of our approach, in many aspects our work is motivated by Oh et al. (2015) and Chiappa et al. (2017), however we focus on using video prediction in the context of learning how to play the game well and positively verify that learned simulators can be used to train a policy useful in original environments. An important step in this direction was made by Leibfried et al. (2016), which extends the work of Oh et al. (2015) by including reward prediction, but does not use the model to learn policies that play the games. Most of these approaches, including ours, encode knowledge of the game in implicit way. Unlike this, there are works in which modeling is more explicit, for example Ersen & Sariel (2014) uses testbed of the Incredible Machines to learn objects behaviors and their interactions. Similarly Guzdial et al. (2017) learns an engine predicting interactions of predeﬁned set of sprites in the domain of Super Mario Bros.
Perhaps surprisingly, there is virtually no work on model-based RL in video games from images. Notable exceptions are the works of Oh et al. (2017), Sodhani et al. (2019), Ha & Schmidhuber (2018), Holland et al. (2018), Leibfried et al. (2018) and Azizzadenesheli et al. (2018). Oh et al. (2017) use a model of rewards to augment model-free learning with good results on a number of Atari games. However, this method does not actually aim to model or predict future frames, and achieves clear but relatively modest gains in efﬁciency. Sodhani et al. (2019) proposes learning a model consistent with RNN policy which helps to train policies that are more powerful than their model-free baseline. Ha & Schmidhuber (2018) present a way to compose a variational autoencoder with a recurrent neural network into an architecture that is successfully evaluated in the VizDoom environment and on a 2D racing game. The training procedure is similar to Algorithm 1, but only one iteration of the loop is needed as the environments are simple enough to be fully explored with random exploration. Similarly, Alaniz (2018) utilizes a transition model with Monte Carlo tree search to solve a block-placing task in Minecraft. Holland et al. (2018) use a variant of Dyna (Sutton, 1991) to learn a model of the environment and generate experience for policy training in the context of Atari games. Using six Atari games as a benchmark Holland et al. (2018) measure the impact of planning shapes on performance of the Dyna-DQN algorithm and include ablations comparing scores obtained with perfect and imperfect models. Our method achieves around 330% of the Dyna-DQN score on Asterix, 120% on Q-Bert, 150% on Seaquest and 80% on Ms. Pac-Man. Azizzadenesheli et al. (2018) propose an algorithm called Generative Adversarial Tree Search (GATS) and for ﬁve Atari games train a GAN-based world model along with a Q-function. Azizzadenesheli et al. (2018) primarily discuss various failure modes of the GATS algorithm. Our method achieves around 64 times the score of GATS on Pong and 10 times on Breakout. 1
Outside of games, model-based reinforcement learning has been investigated at length for applications such as robotics (Deisenroth et al., 2013). Though most of such works do not use image observations, several recent works have incorporated images into real-world (Finn et al., 2016; Finn & Levine, 2017; Babaeizadeh et al., 2017a; Ebert et al., 2017; Piergiovanni et al., 2018; Paxton et al., 2019; Rybkin et al., 2018; Ebert et al., 2018) and simulated (Watter et al., 2015; Hafner et al., 2019) robotic control. Our video models of Atari environments described in Section 4 are motivated by models developed in the context of robotics. Another source of inspiration are discrete autoencoders proposed by van den Oord et al. (2017) and Kaiser & Bengio (2018).
The structure of the model-based RL algorithm that we employ consists of alternating between learning a model, and then using this model to optimize a policy with model-free reinforcement learning. Variants of this basic algorithm have been proposed in a number of prior works, starting from Dyna Q Sutton (1991) to more recent methods that incorporate deep networks Heess et al. (2015); Feinberg et al. (2018); Kalweit & Boedecker (2017); Kurutach et al. (2018).
1Comparison with Dyna-DQN and GATS is based on random-normalized scores achieved at 100K interactions. Those are approximate, as the authors Dyna-DQN and GATS have not provided tabular results. Authors of Dyna-DQN also report scores on two games which we do not consider: Beam Rider and Space Invaders. For both games the reported scores are close to random scores, as are GATS scores on Asterix.
3

Published as a conference paper at ICLR 2020

Attention Attention
Discretization Bit Predictor

Pixels Embedding

Next Frame 4 Input Frames

8x8 8x8
27x20x128 7x5x128

@training

@inference

discrete latent

skip connections

Legend: deconv

dense recurrent

conv attention

PrFerdaimcteed

softmax

Per Pixel Logits

Pixels Embedding

105x80x12

4x4 4x4 4x4 4x4

105x80x64

14x10x256 27x20x256 53x40x128

7x5x256

4x4
4x3x256

Input Action

4x4
2x2x256

4x4 4x4 4x4 4x4 4x4 4x4

4x3x256

7x5x256

14x10x256

multiplication

27x20x256

53x40x128

105x80x64 105x80x256

Predicted Reward
105x80x3

Figure 2: Architecture of the proposed stochastic model with discrete latent. The input to the model is four stacked frames (as well as the action selected by the agent) while the output is the next predicted frame and expected reward. Input pixels and action are embedded using fully connected layers, and there is per-pixel softmax (256 colors) in the output. This model has two main components. First, the bottom part of the network which consists of a skip-connected convolutional encoder and decoder. To condition the output on the actions of the agent, the output of each layer in the decoder is multiplied with the (learned) embedded action. Second part of the model is a convolutional inference network which approximates the posterior given the next frame, similarly to Babaeizadeh et al. (2017a). At training time, the sampled latent values from the approximated posterior will be discretized into bits. To keep the model differentiable, the backpropagation bypasses the discretization following Kaiser & Bengio (2018). A third LSTM based network is trained to approximate each bit given the previous ones. At inference time, the latent bits are predicted auto-regressively using this network. The deterministic model has the same architecture as this ﬁgure but without the inference network.

3 SIMULATED POLICY LEARNING (SIMPLE)

Reinforcement learning is formalized in Markov decision processes (MDP). An MDP is deﬁned as

a tuple (S, A, P, r, γ), where S is a state space, A is a set of actions available to an agent, P is the

unknown transition kernel, r is the reward function and γ ∈ (0, 1) is the discount factor. In this work

we refer to MDPs as environments and assume that environments do not provide direct access to the

state (i.e., the RAM of Atari 2600 emulator). Instead we use visual observations, typically 210 × 160

RGB images. A single image does not determine the state. In order to reduce environment’s partial

observability, we stack four consecutive frames and use it as the observation. A reinforcement

learning agent interacts with the MDP by issuing actions according to a policy. Formally, policy π is

a mapping from states to probability distributions over A. The quality of a policy is measured by the

value function Eπ

+∞ t=0

γtrt+1|s0

=

s

, which for a starting state s estimates the total discounted

reward gathered by the agent.

In Atari 2600 games our goal is to ﬁnd a policy which Algorithm 1: Pseudocode for SimPLe

maximizes the value function from the beginning of

the game. Crucially, apart from an Atari 2600 emu- Initialize policy π

lator environment env we will use a neural network Initialize model parameters θ of env

simulated environment env which we call a world model and describe in detail in Section 4. The en-

Initialize empty set D while not done do

vironment env shares the action space and reward

collect observations from real env.

space with env and produces visual observations in

D ← D ∪ COLLECT(env, π)

the same format, as it will be trained to mimic env.

update model using collected data.

Our principal aim is to train a policy π using a sim-

θ ← TRAIN_SUPERVISED(env , D)

ulated environment env so that π achieves good per-

update policy using world model.

formance in the original environment env. In this

π ← TRAIN_RL(π, env )

training process we aim to use as few interactions end while

with env as possible. The initial data to train env

comes from random rollouts of env. As this is unlikely to capture all aspects of env, we use the

iterative method presented in Algorithm 1.

4

Published as a conference paper at ICLR 2020
4 WORLD MODELS
In search for an effective world model we experimented with various architectures, both new and modiﬁed versions of existing ones. This search resulted in a novel stochastic video prediction model (visualized in Figure 2) which achieved superior results compared to other previously proposed models. In this section, we describe the details of this architecture and the rationale behind our design decisions. In Section 6 we compare the performance of these models.
Deterministic Model. Our basic architecture, presented as part of Figure 2, resembles the convolutional feedforward network from Oh et al. (2015). The input X consists of four consecutive game frames and an action a. Stacked convolution layers process the visual input. The actions are one-hot-encoded and embedded in a vector which is multiplied channel-wise with the output of the convolutional layers. The network outputs the next frame of the game and the value of the reward.
In our experiments, we varied details of the architecture above. In most cases, we use a stack of four convolutional layers with 64 ﬁlters followed by three dense layers (the ﬁrst two have 1024 neurons). The dense layers are concatenated with 64 dimensional vector with a learnable action embedding. Next, three deconvolutional layers of 64 ﬁlters follow. An additional deconvolutional layer outputs an image of the original 105 × 80 size. The number of ﬁlters is either 3 or 3 × 256. In the ﬁrst case, the output is a real-valued approximation of pixel’s RGB value. In the second case, ﬁlters are followed by softmax producing a probability distribution on the color space. The reward is predicted by a softmax attached to the last fully connected layer. We used dropout equal to 0.2 and layer normalization.
Loss functions. The visual output of our networks is either one ﬂoat per pixel/channel or the categorical 256-dimensional softmax. In both cases, we used the clipped loss max(Loss, C) for a constant C. We found that clipping was crucial for improving the models (measured with the correct reward predictions per sequence metric and successful training using Algorithm 1). We conjecture that clipping substantially decreases the magnitude of gradients stemming from ﬁne-tuning of big areas of background consequently letting the optimization process concentrate on small but important areas (e.g. the ball in Pong). In our experiments, we set C = 10 for L2 loss on pixel values and to C = 0.03 for softmax loss. Note that this means that when the level of conﬁdence about the correct pixel value exceeds 97% (as − ln(0.97) ≈ 0.03) we get no gradients from that pixel any longer.
Scheduled sampling. The model env consumes its own predictions from previous steps and due to compounding errors, the model may drift out of the area of its applicability. Following Bengio et al. (2015); Venkatraman et al. (2016), we mitigate this problem by randomly replacing in training some frames of the input X by the prediction from the previous step while linearly increasing the mixing probability to 100% around the middle of the ﬁrst iteration of the training loop.
Stochastic Models. A stochastic model can be used to deal with limited horizon of past observed frames as well as sprites occlusion and ﬂickering which results to higher quality predictions. Inspired by Babaeizadeh et al. (2017a), we tried a variational autoencoder (Kingma & Welling, 2014) to model the stochasticity of the environment. In this model, an additional network receives the input frames as well as the future target frame as input and approximates the distribution of the posterior. At each timestep, a latent value zt is sampled from this distribution and passed as input to the original predictive model. At test time, the latent values are sampled from an assumed prior N (0, I). To match the assumed prior and the approximate, we use the Kullback–Leibler divergence term as an additional loss term (Babaeizadeh et al., 2017a).
We noticed two major issues with the above model. First, the weight of the KL divergence loss term is game dependent, which is not practical if one wants to deal with a broad portfolio of Atari games. Second, this weight is usually a very small number in the range of [10−3, 10−5] which means that the approximated posterior can diverge signiﬁcantly from the assumed prior. This can result in previously unseen latent values at inference time that lead to poor predictions. We address these issues by utilizing a discrete latent variable similar to Kaiser & Bengio (2018).
As visualized in Figure 2, the proposed stochastic model with discrete latent variables discretizes the latent values into bits (zeros and ones) while training an auxiliary LSTM-based Hochreiter & Schmidhuber (1997) recurrent network to predict these bits autoregressively. At inference time, the latent bits will be generated by this auxiliary network in contrast to sampling from a prior. To make the predictive model more robust to unseen latent bits, we add uniform noise to approximated latent
5

Published as a conference paper at ICLR 2020
values before discretization and apply dropout (Srivastava et al., 2014) on bits after discretization. More details about the architecture is in Appendix C.
5 POLICY TRAINING
We will now describe the details of SimPLe, outlined in Algorithm 1. In step 6 we use the proximal policy optimization (PPO) algorithm (Schulman et al., 2017) with γ = 0.95. The algorithm generates rollouts in the simulated environment env and uses them to improve policy π. The fundamental difﬁculty lays in imperfections of the model compounding over time. To mitigate this problem we use short rollouts of env . Typically every N = 50 steps we uniformly sample the starting state from the ground-truth buffer D and restart env (for experiments with the value of γ and N see Section 6.4). Using short rollouts may have a degrading effect as the PPO algorithm does not have a way to infer effects longer than the rollout length. To ease this problem, in the last step of a rollout we add to the reward the evaluation of the value function. Training with multiple iterations re-starting from trajectories gathered in the real environment is new to our knowledge. It was inspired by the classical Dyna-Q algorithm and, notably, in the Atari domain no comparable results have been achieved.
The main loop in Algorithm 1 is iterated 15 times (cf. Section 6.4). The world model is trained for 45K steps in the ﬁrst iteration and for 15K steps in each of the following ones. Shorter training in later iterations does not degrade the performance because the world model after ﬁrst iteration captures already part of the game dynamics and only needs to be extended to novel situations.
In each of the iterations, the agent is trained inside the latest world model using PPO. In every PPO epoch we used 16 parallel agents collecting 25, 50 or 100 steps from the simulated environment env (see Section 6.4 for ablations). The number of PPO epochs is z · 1000, where z equals to 1 in all passes except last one (where z = 3) and two passes number 8 and 12 (where z = 2). This gives 800K·z interactions with the simulated environment in each of the loop passes. In the process of training the agent performs 15.2M interactions with the simulated environment env .
6 EXPERIMENTS
We evaluate SimPLe on a suite of Atari games from Atari Learning Environment (ALE) benchmark. In our experiments, the training loop is repeated for 15 iterations, with 6400 interactions with the environment collected in each iteration. We apply a standard pre-processing for Atari games: a frame skip equal to 4, that is every action is repeated 4 times. The frames are down-scaled by a factor of 2.
Because some data is collected before the ﬁrst iteration of the loop, altogether 6400 · 16 = 102, 400 interactions with the Atari environment are used during training. This is equivalent to 409, 600 frames from the Atari game (114 minutes at 60 FPS). At every iteration, the latest policy trained under the learned model is used to collect data in the real environment env. The data is also directly used to train the policy with PPO. Due to vast difference between number of training data from simulated environment and real environment (15M vs 100K) the impact of the latter on policy is negligible.
We evaluate our method on 26 games selected on the basis of being solvable with existing state-ofthe-art model-free deep RL algorithms2, which in our comparisons are Rainbow Hessel et al. (2018) and PPO Schulman et al. (2017). For Rainbow, we used the implementation from the Dopamine package and spent considerable time tuning it for sample efﬁciency (see Appendix E).
For visualization of all experiments see https://goo.gl/itykP8 and for a summary see Figure 3. It can be seen that our method is more sample-efﬁcient than a highly tuned Rainbow baseline on almost all games, requires less than half of the samples on more than half of the games and, on Freeway, is more than 10x more sample-efﬁcient. Our method outperforms PPO by an even larger margin. We also compare our method with ﬁxed score baselines (for different baselines) rather than counting how many steps are required to match our score, see Figure 4 for the results. For the
2Speciﬁcally, for the ﬁnal evaluation we selected games which achieved non-random results using our method or the Rainbow algorithm using 100K interactions.
6

Published as a conference paper at ICLR 2020
Figure 3: Comparison with Rainbow and PPO. Each bar illustrates the number of interactions with environment required by Rainbow (left) or PPO (right) to achieve the same score as our method (SimPLe). The red line indicates the 100K interactions threshold which is used by the our method.
qualitative analysis of performance on different games see Appendix B. The source code is available as part of the Tensor2Tensor library and it includes instructions on how to run the experiments3.
6.1 SAMPLE EFFICIENCY The primary evaluation in our experiments studies the sample efﬁciency of SimPLe, in comparison with state-of-the-art model-free deep RL methods in the literature. To that end, we compare with Rainbow (Hessel et al., 2018; Castro et al., 2018), which represents the state-of-the-art Q-learning method for Atari games, and PPO (Schulman et al., 2017), a model-free policy gradient algorithm (see Appendix E for details of tuning of Rainbow and PPO). The results of the comparison are presented in Figure 3. For each game, we plot the number of time steps needed for either Rainbow or PPO to reach the same score that our method reaches after 100K interaction steps. The red line indicates 100K steps: any bar larger than this indicates a game where the model-free method required more steps. SimPLe outperforms the model-free algorithms in terms of learning speed on nearly all of the games, and in the case of a few games, does so by over an order of magnitude. For some games, it reaches the same performance that our PPO implementation reaches at 10M steps. This indicates that model-based reinforcement learning provides an effective approach to learning Atari games, at a fraction of the sample complexity. The results in these ﬁgures are generated by averaging 5 runs for each game. The model-based agent is better than a random policy for all the games except Bank Heist. Interestingly, we observed that the best of the 5 runs was often signiﬁcantly better. For 6 of the games, it exceeds the average human score (as reported in Table 3 of Pohlen et al. (2018)). This suggests that further stabilizing SimPLe should improve its performance, indicating an important direction for future work. In some cases during training we observed high variance of the results during each step of the loop. There are a number of possible reasons, such as mutual interactions of the policy training and the supervised training or domain mismatch between the model and the real environment. We present detailed numerical results, including best scores and standard deviations, in Appendix D.
3https://github.com/tensorflow/tensor2tensor/tree/master/tensor2tensor/ rl
7

Published as a conference paper at ICLR 2020

number of samples to match number of samples to match

Figure 4: Fractions of Rainbow and PPO scores at different numbers of interactions calculated with the formula (SimP Le_score@100K − random_score)/(baseline_score − random_score); if denominator is smaller than 0, both nominator and denominator are increased by 1. From left to right, the baselines are: Rainbow at 100K, Rainbow at 200K, PPO at 100K, PPO at 200K. SimPLe outperforms Rainbow and PPO even when those are given twice as many interactions.

1e6

1.0

SimPle, mean over 5 runs SimPLe, max over 5 runs

0.8

1e6

1.0

SimPle+PPO, mean over 5 runs SimPle+PPO, max over 5 runs

0.8

0.6

0.6

0.4

0.4

0.2

0.2

0.0

0.0

0.0

0.2

0.n4umber of samp0le.6s

0.8

1.01e6

0.0

0.2

0.n4umber of samp0le.6s

0.8

1.01e6

(a) Model based (SimPLe)

(b) Model based + model free (SimPLe + PPO)

Figure 5: Behaviour with respect to the number of used samples. We report number of frames required by PPO to reach the score of our models. Results are averaged over all games.

6.2 NUMBER OF FRAMES
We focused our work on learning games with 100K interaction steps with the environment. In this section we present additional results for settings with 20K, 50K, 200K, 500K and 1M interactions; see Figure 5 (a). Our results are poor with 20K interactions. For 50K they are already almost as good as with 100K interactions. From there the results improve until 500K samples – it is also the point at which they are on par with model-free PPO. Detailed per game results can be found in Appendix F.
This demonstrates that SimPLe excels in a low data regime, but its advantage disappears with a bigger amount of data. Such a behavior, with fast growth at the beginning of training, but lower asymptotic performance is commonly observed when comparing model-based and model-free methods (Wang et al. (2019)). As observed in Section 6.4 assigning bigger computational budget helps in 100K setting. We suspect that gains would be even bigger for the settings with more samples.
Finally, we veriﬁed if a model obtained with SimPLe using 100K is a useful initialization for modelfree PPO training. Based on the results depicted in Figure 5 (b) we can positively answer this conjecture. Lower asymptotic performance is probably due to worse exploration. A policy pre-trained with SimPLe was meant to obtain the best performance on 100K, at which point its entropy is very low thus hindering further PPO training.
8

Published as a conference paper at ICLR 2020
6.3 ENVIRONMENT STOCHASTICITY
A crucial decision in the design of world models is the inclusion of stochasticity. Although Atari is known to be a deterministic environment, it is stochastic given only a limited horizon of past observed frames (in our case 4 frames). The level of stochasticity is game dependent; however, it can be observed in many Atari games. An example of such behavior can be observed in the game Kung Fu Master – after eliminating the current set of opponents, the game screen always looks the same (it contains only player’s character and the background). The game dispatches diverse sets of new opponents, which cannot be inferred from the visual observation alone (without access to the game’s internal state) and thus cannot be predicted by a deterministic model. Similar issues have been reported in Babaeizadeh et al. (2017a), where the output of their baseline deterministic model was a blurred superposition of possible random object movements. As can be seen in Figure 11 in the Appendix, the stochastic model learns a reasonable behavior – samples potential opponents and renders them sharply.
Given the stochasticity of the proposed model, SimPLe can be used with truly stochastic environments. To demonstrate this, we ran an experiment where the full pipeline (both the world model and the policy) was trained in the presence of sticky actions, as recommended in (Machado et al., 2018, Section 5). Our world model learned to account for the stickiness of actions and in most cases the end results were very similar to the ones for the deterministic case even without any tuning, see Figure 6.
6.4 ABLATIONS
To evaluate the design of our method, we independently varied a number of the design decisions. Here we present an overview; see Appendix A for detailed results. Model architecture and hyperparameters. We evaluated a few choices for the world model and our proposed stochastic discrete model performs best by a signiﬁcant margin. The second most important parameter was the length of world model’s training. Figure 6: Impact of the environment stochasticity. We veriﬁed that a longer training would be beneﬁcial, The graphs are in the same format as Figure 3: however we had to restrict it in all other ablation stud- each bar illustrates the number of interactions with ies due to a high cost of training on all games. As for environment required by Rainbow to achieve the the length of rollouts from simulated env , we use same score as SimPLe (with stochastic discrete N = 50 by default. We experimentally shown that world model) using 100k steps in an environment N = 25 performs roughly on par, while N = 100 is with and without sticky actions. slightly worse, likely due to compounding model errors. The discount factor was set to γ = 0.99 unless speciﬁed otherwise. We see that γ = 0.95 is slightly better than other values, and we hypothesize that it is due to better tolerance to model imperfections. But overall, all three values of γ perform comparably. Model-based iterations. The iterative process of training the model, training the policy, and collecting data is crucial for non-trivial tasks where random data collection is insufﬁcient. In a game-by-game analysis, we quantiﬁed the number of games where the best results were obtained in later iterations of training. In some games, good policies could be learned very early. While this might have been due to the high variability of training, it does suggest the possibility of much faster training (i.e. in fewer step than 100k) with more directed exploration policies. In Figure 9 in the Appendix we present the cumulative distribution plot for the (ﬁrst) point during learning when the maximum score for the run was achieved in the main training loop of Algorithm 1. Random starts. Using short rollouts is crucial to mitigate the compounding errors in the model. To ensure exploration, SimPLe starts rollouts from randomly selected states taken from the real data buffer D. Figure 9 compares the baseline with an experiment without random starts and rollouts of length 1000 on Seaquest which shows much worse results without random starts.
9

Published as a conference paper at ICLR 2020
7 CONCLUSIONS AND FUTURE WORK
We presented SimPLe, a model-based reinforcement learning approach that operates directly on raw pixel observations and learns effective policies to play games in the Atari Learning Environment. Our experiments demonstrate that SimPLe learns to play many of the games with just 100K interactions with the environment, corresponding to 2 hours of play time. In many cases, the number of samples required for prior methods to learn to reach the same reward value is several times larger.
Our predictive model has stochastic latent variables so it can be applied in highly stochastic environments. Studying such environments is an exciting direction for future work, as is the study of other ways in which the predictive neural network model could be used. Our approach uses the model as a learned simulator and directly applies model-free policy learning to acquire the policy. However, we could use the model for planning. Also, since our model is differentiable, the additional information contained in its gradients could be incorporated into the reinforcement learning process. Finally, the representation learned by the predictive model is likely be more meaningful by itself than the raw pixel observations from the environment. Incorporating this representation into the policy could further accelerate and improve the reinforcement learning process.
While SimPLe is able to learn more quickly than model-free methods, it does have limitations. First, the ﬁnal scores are on the whole lower than the best state-of-the-art model-free methods. This can be improved with better dynamics models and, while generally common with model-based RL algorithms, suggests an important direction for future work. Another, less obvious limitation is that the performance of our method generally varied substantially between different runs on the same game. The complex interactions between the model, policy, and data collection were likely responsible for this. In future work, models that capture uncertainty via Bayesian parameter posteriors or ensembles (Kurutach et al., 2018; Chua et al., 2018) may improve robustness. Finally, the computational and time requirement of training inside world model are substantial (see Appendix C), which makes developing lighter models an important research direction.
In this paper our focus was to demonstrate the capability and generality of SimPLe only across a suite of Atari games, however, we believe similar methods can be applied to other environments and tasks which is one of our main directions for future work. As a long-term challenge, we believe that model-based reinforcement learning based on stochastic predictive models represents a promising and highly efﬁcient alternative to model-free RL. Applications of such approaches to both high-ﬁdelity simulated environments and real-world data represent an exciting direction for future work that can enable highly efﬁcient learning of behaviors from raw sensory inputs in domains such as robotics and autonomous driving.
ACKNOWLEDGMENTS
We thank Marc Bellemare and Pablo Castro for their help with Rainbow and Dopamine. The work of Konrad Czechowski, Piotr Kozakowski and Piotr Miłos´ was supported by the Polish National Science Center grants UMO-2017/26/E/ST6/00622. The work of Henryk Michalewski was supported by the Polish National Science Center grant UMO-2018/29/B/ST6/02959. This research was supported by the PL-Grid Infrastructure. In particular, Konrad Czechowski, Piotr Kozakowski, Henryk Michalewski, Piotr Miłos´ and Błaz˙ej Osin´ski extensively used the Prometheus supercomputer, located in the Academic Computer Center Cyfronet in the AGH University of Science and Technology in Kraków, Poland. Some of the experiments were managed using https://neptune.ai. We would like to thank the Neptune team for providing us access to the team version and technical support.
REFERENCES
Stephan Alaniz. Deep reinforcement learning with model learning and monte carlo tree search in minecraft. arXiv preprint arXiv:1803.08456, 2018.
Kamyar Azizzadenesheli, Brandon Yang, Weitang Liu, Emma Brunskill, Zachary C. Lipton, and Animashree Anandkumar. Sample-efﬁcient deep RL with generative adversarial tree search. CoRR, abs/1806.05780, 2018.
10

Published as a conference paper at ICLR 2020
Mohammad Babaeizadeh, Chelsea Finn, Dumitru Erhan, Roy H. Campbell, and Sergey Levine. Stochastic variational video prediction. ICLR, 2017a.
Mohammad Babaeizadeh, Iuri Frosio, Stephen Tyree, Jason Clemons, and Jan Kautz. Reinforcement learning through asynchronous advantage actor-critic on a GPU. In 5th International Conference on Learning Representations, ICLR 2017, Toulon, France, April 24-26, 2017, Conference Track Proceedings. OpenReview.net, 2017b. URL https://openreview.net/forum? id=r1VGvBcxl.
Marc G. Bellemare, Yavar Naddaf, Joel Veness, and Michael Bowling. The arcade learning environment: An evaluation platform for general agents (extended abstract). In Proceedings of the Twenty-Fourth International Joint Conference on Artiﬁcial Intelligence, IJCAI, pp. 4148–4152, 2015.
Samy Bengio, Oriol Vinyals, Navdeep Jaitly, and Noam Shazeer. Scheduled sampling for sequence prediction with recurrent neural networks. In Advances in Neural Information Processing Systems 28: Annual Conference on Neural Information Processing Systems 2015, December 7-12, 2015, Montreal, Quebec, Canada, pp. 1171–1179, 2015.
Lars Buesing, Theophane Weber, Yori Zwols, Nicolas Heess, Sébastien Racanière, Arthur Guez, and Jean-Baptiste Lespiau. Woulda, coulda, shoulda: Counterfactually-guided policy search. In 7th International Conference on Learning Representations, ICLR 2019, New Orleans, LA, USA, May 6-9, 2019. OpenReview.net, 2019. URL https://openreview.net/forum? id=BJG0voC9YQ.
Pablo Samuel Castro, Subhodeep Moitra, Carles Gelada, Saurabh Kumar, and Marc G. Bellemare. Dopamine: A research framework for deep reinforcement learning. CoRR, abs/1812.06110, 2018.
Silvia Chiappa, Sébastien Racanière, Daan Wierstra, and Shakir Mohamed. Recurrent environment simulators. In 5th International Conference on Learning Representations, ICLR 2017, Toulon, France, April 24-26, 2017, Conference Track Proceedings. OpenReview.net, 2017. URL https: //openreview.net/forum?id=B1s6xvqlx.
Kurtland Chua, Roberto Calandra, Rowan McAllister, and Sergey Levine. Deep reinforcement learning in a handful of trials using probabilistic dynamics models. In Advances in Neural Information Processing Systems, pp. 4759–4770, 2018.
Marc Peter Deisenroth, Gerhard Neumann, and Jan Peters. A survey on policy search for robotics. Foundations and Trends in Robotics, 2(1-2), 2013.
Frederik Ebert, Chelsea Finn, Alex X. Lee, and Sergey Levine. Self-supervised visual planning with temporal skip connections. In 1st Annual Conference on Robot Learning, CoRL 2017, Mountain View, California, USA, November 13-15, 2017, Proceedings, volume 78 of Proceedings of Machine Learning Research, pp. 344–356. PMLR, 2017.
Frederik Ebert, Chelsea Finn, Sudeep Dasari, Annie Xie, Alex Lee, and Sergey Levine. Visual foresight: Model-based deep reinforcement learning for vision-based robotic control. arXiv preprint arXiv:1812.00568, 2018.
Mustafa Ersen and Sanem Sariel. Learning behaviors of and interactions among objects through spatio–temporal reasoning. IEEE Transactions on Computational Intelligence and AI in Games, 7 (1):75–87, 2014.
Lasse Espeholt, Hubert Soyer, Rémi Munos, Karen Simonyan, Volodymyr Mnih, Tom Ward, Yotam Doron, Vlad Firoiu, Tim Harley, Iain Dunning, Shane Legg, and Koray Kavukcuoglu. IMPALA: scalable distributed deep-rl with importance weighted actor-learner architectures. In Proceedings of the 35th International Conference on Machine Learning, ICML, pp. 1406–1415, 2018.
Vladimir Feinberg, Alvin Wan, Ion Stoica, Michael I. Jordan, Joseph E. Gonzalez, and Sergey Levine. Model-based value estimation for efﬁcient model-free reinforcement learning. CoRR, abs/1803.00101, 2018.
Chelsea Finn and Sergey Levine. Deep visual foresight for planning robot motion. In 2017 IEEE International Conference on Robotics and Automation, ICRA 2017, Singapore, Singapore, May 29 - June 3, 2017, pp. 2786–2793. IEEE, 2017. doi: 10.1109/ICRA.2017.7989324.
Chelsea Finn, Xin Yu Tan, Yan Duan, Trevor Darrell, Sergey Levine, and Pieter Abbeel. Deep spatial autoencoders for visuomotor learning. In IEEE International Conference on Robotics and Automation, ICRA, pp. 512–519, 2016.
Matthew Guzdial, Boyang Li, and Mark O. Riedl. Game engine learning from video. In Proceedings of the Twenty-Sixth International Joint Conference on Artiﬁcial Intelligence, IJCAI 2017, Melbourne, Australia, August 19-25, 2017, pp. 3707–3713, 2017. doi: 10.24963/ijcai.2017/518.
11

Published as a conference paper at ICLR 2020
David Ha and Jürgen Schmidhuber. Recurrent world models facilitate policy evolution. In Samy Bengio, Hanna M. Wallach, Hugo Larochelle, Kristen Grauman, Nicolò Cesa-Bianchi, and Roman Garnett (eds.), Advances in Neural Information Processing Systems 31: Annual Conference on Neural Information Processing Systems 2018, NeurIPS 2018, 3-8 December 2018, Montréal, Canada, pp. 2455–2467, 2018.
Danijar Hafner, Timothy P. Lillicrap, Ian Fischer, Ruben Villegas, David Ha, Honglak Lee, and James Davidson. Learning latent dynamics for planning from pixels. In Kamalika Chaudhuri and Ruslan Salakhutdinov (eds.), Proceedings of the 36th International Conference on Machine Learning, ICML 2019, 9-15 June 2019, Long Beach, California, USA, volume 97 of Proceedings of Machine Learning Research, pp. 2555–2565. PMLR, 2019.
Nicolas Heess, Gregory Wayne, David Silver, Timothy P. Lillicrap, Tom Erez, and Yuval Tassa. Learning continuous control policies by stochastic value gradients. In Corinna Cortes, Neil D. Lawrence, Daniel D. Lee, Masashi Sugiyama, and Roman Garnett (eds.), Advances in Neural Information Processing Systems 28: Annual Conference on Neural Information Processing Systems 2015, December 7-12, 2015, Montreal, Quebec, Canada, pp. 2944–2952, 2015.
Matteo Hessel, Joseph Modayil, Hado van Hasselt, Tom Schaul, Georg Ostrovski, Will Dabney, Dan Horgan, Bilal Piot, Mohammad Gheshlaghi Azar, and David Silver. Rainbow: Combining improvements in deep reinforcement learning. In Sheila A. McIlraith and Kilian Q. Weinberger (eds.), Proceedings of the Thirty-Second AAAI Conference on Artiﬁcial Intelligence, (AAAI-18), the 30th innovative Applications of Artiﬁcial Intelligence (IAAI-18), and the 8th AAAI Symposium on Educational Advances in Artiﬁcial Intelligence (EAAI-18), New Orleans, Louisiana, USA, February 2-7, 2018, pp. 3215–3222. AAAI Press, 2018.
Sepp Hochreiter and Jürgen Schmidhuber. Long short-term memory. Neural computation, 9(8): 1735–1780, 1997.
G. Zacharias Holland, Erik Talvitie, and Michael Bowling. The effect of planning shape on dyna-style planning in high-dimensional state spaces. CoRR, abs/1806.01825, 2018.
Lukasz Kaiser and Samy Bengio. Discrete autoencoders for sequence models. CoRR, abs/1801.09797, 2018.
Gabriel Kalweit and Joschka Boedecker. Uncertainty-driven imagination for continuous deep reinforcement learning. In Sergey Levine, Vincent Vanhoucke, and Ken Goldberg (eds.), Proceedings of the 1st Annual Conference on Robot Learning, volume 78 of Proceedings of Machine Learning Research, pp. 195–206. PMLR, 13–15 Nov 2017.
Kacper Piotr Kielak. Do recent advancements in model-based deep reinforcement learning really improve data efﬁciency?, 2020. URL https://openreview.net/forum?id= Bke9u1HFwB.
Diederik P. Kingma and Max Welling. Auto-encoding variational bayes. In Yoshua Bengio and Yann LeCun (eds.), 2nd International Conference on Learning Representations, ICLR 2014, Banff, AB, Canada, April 14-16, 2014, Conference Track Proceedings, 2014.
Thanard Kurutach, Ignasi Clavera, Yan Duan, Aviv Tamar, and Pieter Abbeel. Model-ensemble trust-region policy optimization. In 6th International Conference on Learning Representations, ICLR 2018, Vancouver, BC, Canada, April 30 - May 3, 2018, Conference Track Proceedings. OpenReview.net, 2018. URL https://openreview.net/forum?id=SJJinbWRZ.
Felix Leibfried, Nate Kushman, and Katja Hofmann. A deep learning approach for joint video frame and reward prediction in Atari games. CoRR, abs/1611.07078, 2016.
Felix Leibfried, Rasul Tutunov, Peter Vrancx, and Haitham Bou-Ammar. Model-based regularization for deep reinforcement learning with transcoder networks. arXiv preprint arXiv:1809.01906, 2018.
Marlos C. Machado, Marc G. Bellemare, Erik Talvitie, Joel Veness, Matthew J. Hausknecht, and Michael Bowling. Revisiting the arcade learning environment: Evaluation protocols and open problems for general agents. J. Artif. Intell. Res., 61:523–562, 2018. doi: 10.1613/jair.5699.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wierstra, and Martin A. Riedmiller. Playing atari with deep reinforcement learning. CoRR, abs/1312.5602, 2013.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A. Rusu, Joel Veness, Marc G. Bellemare, Alex Graves, Martin A. Riedmiller, Andreas Fidjeland, Georg Ostrovski, Stig Petersen, Charles Beattie, Amir Sadik, Ioannis Antonoglou, Helen King, Dharshan Kumaran, Daan Wierstra, Shane Legg, and Demis Hassabis. Human-level control through deep reinforcement learning. Nature, 518(7540):529–533, 2015.
12

Published as a conference paper at ICLR 2020
Volodymyr Mnih, Adrià Puigdomènech Badia, Mehdi Mirza, Alex Graves, Timothy P. Lillicrap, Tim Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement learning. In Proceedings of the 33nd International Conference on Machine Learning, ICML, pp. 1928–1937, 2016.
Junhyuk Oh, Xiaoxiao Guo, Honglak Lee, Richard L. Lewis, and Satinder P. Singh. Actionconditional video prediction using deep networks in atari games. In NIPS, pp. 2863–2871, 2015.
Junhyuk Oh, Satinder Singh, and Honglak Lee. Value prediction network. In I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.), Advances in Neural Information Processing Systems 30, pp. 6118–6128. Curran Associates, Inc., 2017.
Chris Paxton, Yotam Barnoy, Kapil D. Katyal, Raman Arora, and Gregory D. Hager. Visual robot task planning. In International Conference on Robotics and Automation, ICRA 2019, Montreal, QC, Canada, May 20-24, 2019, pp. 8832–8838. IEEE, 2019. doi: 10.1109/ICRA.2019.8793736.
A. J. Piergiovanni, Alan Wu, and Michael S. Ryoo. Learning real-world robot policies by dreaming. CoRR, abs/1805.07813, 2018.
Tobias Pohlen, Bilal Piot, Todd Hester, Mohammad Gheshlaghi Azar, Dan Horgan, David Budden, Gabriel Barth-Maron, Hado van Hasselt, John Quan, Mel Vecerík, Matteo Hessel, Rémi Munos, and Olivier Pietquin. Observe and look further: Achieving consistent performance on atari. CoRR, abs/1805.11593, 2018.
Oleh Rybkin, Karl Pertsch, Andrew Jaegle, Konstantinos G. Derpanis, and Kostas Daniilidis. Unsupervised learning of sensorimotor affordances by stochastic future prediction. CoRR, abs/1806.09655, 2018.
Jürgen Schmidhuber. Formal theory of creativity, fun, and intrinsic motivation (1990-2010). IEEE Trans. Autonomous Mental Development, 2(3):230–247, 2010.
John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization algorithms. CoRR, abs/1707.06347, 2017.
Shagun Sodhani, Anirudh Goyal, Tristan Deleu, Yoshua Bengio, Sergey Levine, and Jian Tang. Learning powerful policies by using consistent dynamics model. arXiv preprint arXiv:1906.04355, 2019.
Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout: a simple way to prevent neural networks from overﬁtting. The Journal of Machine Learning Research, 15(1):1929–1958, 2014.
Richard S. Sutton. Dyna, an integrated architecture for learning, planning, and reacting. SIGART Bull., 2(4):160–163, July 1991.
Richard S. Sutton and Andrew G. Barto. Reinforcement learning - an introduction, 2nd edition (work in progress). Adaptive computation and machine learning. MIT Press, 2017.
Pedro Tsividis, Thomas Pouncy, Jaqueline L. Xu, Joshua B. Tenenbaum, and Samuel J. Gershman. Human learning in atari. In 2017 AAAI Spring Symposia, Stanford University, Palo Alto, California, USA, March 27-29, 2017, 2017.
Aäron van den Oord, Oriol Vinyals, and Koray Kavukcuoglu. Neural discrete representation learning. In Isabelle Guyon, Ulrike von Luxburg, Samy Bengio, Hanna M. Wallach, Rob Fergus, S. V. N. Vishwanathan, and Roman Garnett (eds.), Advances in Neural Information Processing Systems 30: Annual Conference on Neural Information Processing Systems 2017, 4-9 December 2017, Long Beach, CA, USA, pp. 6306–6315, 2017.
Hado van Hasselt, Matteo Hessel, and John Aslanides. When to use parametric models in reinforcement learning? In Hanna M. Wallach, Hugo Larochelle, Alina Beygelzimer, Florence d’Alché-Buc, Emily B. Fox, and Roman Garnett (eds.), Advances in Neural Information Processing Systems 32: Annual Conference on Neural Information Processing Systems 2019, NeurIPS 2019, 8-14 December 2019, Vancouver, BC, Canada, pp. 14322–14333, 2019.
Arun Venkatraman, Roberto Capobianco, Lerrel Pinto, Martial Hebert, Daniele Nardi, and J. Andrew Bagnell. Improved learning of dynamics models for control. In International Symposium on Experimental Robotics, ISER 2016, Tokyo, Japan, October 3-6, 2016., pp. 703–713, 2016.
Tingwu Wang, Xuchan Bao, Ignasi Clavera, Jerrick Hoang, Yeming Wen, Eric Langlois, Shunshi Zhang, Guodong Zhang, Pieter Abbeel, and Jimmy Ba. Benchmarking model-based reinforcement learning. CoRR, abs/1907.02057, 2019.
Manuel Watter, Jost Tobias Springenberg, Joschka Boedecker, and Martin A. Riedmiller. Embed to control: A locally linear latent dynamics model for control from raw images. In Advances in Neural Information Processing Systems, pp. 2746–2754, 2015.
13

Published as a conference paper at ICLR 2020 Yuhuai Wu, Elman Mansimov, Roger B. Grosse, Shun Liao, and Jimmy Ba. Scalable trust-region
method for deep reinforcement learning using kronecker-factored approximation. In Isabelle Guyon, Ulrike von Luxburg, Samy Bengio, Hanna M. Wallach, Rob Fergus, S. V. N. Vishwanathan, and Roman Garnett (eds.), Advances in Neural Information Processing Systems 30: Annual Conference on Neural Information Processing Systems 2017, 4-9 December 2017, Long Beach, CA, USA, pp. 5279–5288, 2017.
14

Published as a conference paper at ICLR 2020

Table 1: Summary of SimPLe ablations. For each game, a conﬁguration was assigned a score being the mean over 5 experiments. The best and median scores were calculated per game. The table reports the number of games a given conﬁguration achieved the best score or at least the median score, respectively.

model

best at least median

deterministic 0

7

det. recurrent 3

13

SD

8

16

SD γ = 0.9

1

14

default

10

21

SD 100 steps 0

14

SD 25 steps

4

19

All our code is available as part of the Tensor2Tensor library and it includes instructions on how to run our experiments: https://github.com/tensorflow/tensor2tensor/tree/ master/tensor2tensor/rl.
A ABLATIONS
To evaluate the design of our method, we independently varied a number of the design decisions: the choice of the model, the γ parameter and the length of PPO rollouts. The results for 7 experimental conﬁgurations are summarized in the Table 1.
Models. To assess the model choice, we evaluated the following models: deterministic, deterministic recurrent, and stochastic discrete (see Section 4). Based on Table 1 it can be seen that our proposed stochastic discrete model performs best. Figures 7a and 7b show the role of stochasticity and recurrence.
Steps. See Figure 7d. As described in Section 5 every N steps we reinitialize the simulated environment with ground-truth data. By default we use N = 50, in some experiments we set N = 25 or N = 100. It is clear from the table above and Figure 7d that 100 is a bit worse than either 25 or 50, likely due to compounding model errors, but this effect is much smaller than the effect of model architecture.
Gamma. See Figure 8b. We used the discount factor γ = 0.99 unless speciﬁed otherwise. We see that γ = 0.95 is slightly better than other values, and we hypothesize that it is due to better tolerance to model imperfections. But overall, all three values of γ seem to perform comparably at the same number of steps.
Model-based iterations. The iterative process of training the model, training the policy, and collecting data is crucial for non-trivial tasks where simple random data collection is insufﬁcient. In the game-by-game analysis, we quantiﬁed the number of games where the best results were obtained in later iterations of training. In some games, good policies could be learned very early. While this might have been due simply to the high variability of training, it does suggest the possibility that much faster training – in many fewer than 100k steps – could be obtained in future work with more directed exploration policies. We leave this question to future work.
In Figure 9 we present the cumulative distribution plot for the (ﬁrst) point during learning when the maximum score for the run was achieved in the main training loop of Algorithm 1.
On Figure 7c we show results for experiments in which the number samples was ﬁxed to be 100K but the number of training loop varied. We conclude that 15 is beneﬁcial for training.
Long model training Our best results were obtained with much 5 times longer training of the world models, see Figure 8a for comparison with shorter training. Due to our resources constraints other ablations were made with the short model training setting.
15

Published as a conference paper at ICLR 2020
Random starts. Using short rollouts is crucial to mitigate the compounding errors under the model. To ensure exploration SimPLe starts rollouts from randomly selected states taken from the real data buffer D. In Figure 9 we present a comparison with an experiment without random starts and rollouts of length 1000 on Seaquest. These data strongly indicate that ablating random starts substantially deteriorate results.
B QUALITATIVE ANALYSIS
This section provides a qualitative analysis and case studies of individual games. We emphasize that we did not adjust the method nor hyperparameters individually for each game, but we provide speciﬁc qualitative analysis to better understand the predictions from the model.4
Solved games. The primary goal of our paper was to use model-based methods to achieve good performance within a modest budget of 100k interactions. For two games, Pong and Freeway, our method, SimPLe, was able to achieve the maximum score.
Exploration. Freeway is a particularly interesting game. Though simple, it presents a substantial exploration challenge. The chicken, controlled by the agents, is quite slow to ascend when exploring randomly as it constantly gets bumped down by the cars (see the left video https://goo.gl/YHbKZ6). This makes it very unlikely to fully cross the road and obtain a non-zero reward. Nevertheless, SimPLe is able to capture such rare events, internalize them into the predictive model and then successfully learn a successful policy.
However, this good performance did not happen on every run. We conjecture the following scenario in failing cases. If at early stages the entropy of the policy decayed too rapidly the collected experience stayed limited leading to a poor world model, which was not powerful enough to support exploration (e.g. the chicken disappears when moving to high). In one of our experiments, we observed that the ﬁnal policy was that the chicken moved up only to the second lane and stayed waiting to be hit by the car and so on so forth.
Pixel-perfect games. In some cases (for Pong, Freeway, Breakout) our models were able to predict the future perfectly, down to every pixel. This property holds for rather short time intervals, we observed episodes lasting up to 50 time-steps. Extending it to long sequences would be a very exciting research direction. See videos https://goo.gl/uyfNnW.
Benign errors. Despite the aforementioned positive examples, accurate models are difﬁcult to acquire for some games, especially at early stages of learning. However, model-based RL should be tolerant to modest model errors. Interestingly, in some cases our models differed from the original games in a way that was harmless or only mildly harmful for policy training.
For example, in Bowling and Pong, the ball sometimes splits into two. While nonphysical, seemingly these errors did not distort much the objective of the game, see Figure 10 and also https://goo.gl/JPi7rB.
In Kung Fu Master our model’s predictions deviate from the real game by spawning a different number of opponents, see Figure 11. In Crazy Climber we observed the bird appearing earlier in the game. These cases are probably to be attributed to the stochasticity in the model. Though not aligned with the true environment, the predicted behaviors are plausible, and the resulting policy can still play the original game.
Failures on hard games. On some of the games, our models simply failed to produce useful predictions. We believe that listing such errors may be helpful in designing better training protocols and building better models. The most common failure was due to the presence of very small but highly relevant objects. For example, in Atlantis and Battle Zone bullets are so small that they tend to disappear. Interestingly, Battle Zone has pseudo-3D graphics, which may have added to the difﬁculty. See videos https://goo.gl/uiccKU.
4We strongly encourage the reader to watch accompanying videos https://goo.gl/itykP8
16

Published as a conference paper at ICLR 2020

freeway krull
kung fu master kangaroo
chopper command asterix pong
crazy climber road runner boxing frostbite breakout qbert amidar battle zone jamesbond ms pacman seaquest alien up n down assault gopher hero private eye
demon attack bank heist

stochastic deterministic

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1e5

(a) Effect of stochasticity.

freeway krull
kung fu master kangaroo
chopper command asterix pong
crazy climber road runner boxing frostbite breakout qbert amidar battle zone jamesbond ms pacman seaquest alien up n down assault gopher hero private eye
demon attack bank heist

non-recurrent recurrent

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1e5

(b) Effect of recurrent architecture.

freeway ms pacman kung fu master crazy climber
kangaroo krull pong qbert
asterix assault road runner amidar breakout battle zone frostbite seaquest
alien up n down
gopher jamesbond demon attack private eye
hero bank heist chopper command
boxing

15 iterations [default] 3 iterations 1 iteration

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1e5

(c) Effect of adjusting of number of epochs.

freeway private eye
asterix kangaroo kung fu master
pong chopper command
road runner assault
jamesbond crazy climber
battle zone frostbite amidar qbert alien boxing krull
ms pacman breakout seaquest
up n down gopher hero
demon attack bank heist

steps = 25 steps = 50 [default] steps = 100

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1e5

(d) Effect of adjusting of number of steps.

Figure 7: Ablations part 1. The graphs are in the same format as Figure 3: each bar illustrates the number of interactions with environment required by Rainbow to achieve the same score as a particular variant of SimPLe. The red line indicates the 100K interactions threshold which is used by SimPLe.
17

Published as a conference paper at ICLR 2020

freeway ms pacman kung fu master crazy climber
kangaroo krull pong qbert
asterix assault road runner amidar breakout battle zone frostbite seaquest
alien up n down
gopher jamesbond demon attack private eye
hero bank heist chopper command
boxing

short extended

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1e5

(a) Effect of extended model training.

freeway krull
kung fu master kangaroo
chopper command asterix pong
crazy climber road runner boxing frostbite breakout qbert amidar battle zone jamesbond ms pacman seaquest alien up n down assault gopher hero private eye
demon attack bank heist

γ = 0.99 default γ = 0.95 γ = 0.90

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1e5

(b) Effect of adjusting γ in PPO training

Figure 8: Ablations part 2. The graphs are in the same format as Figure 3: each bar illustrates the number of interactions with environment required by Rainbow to achieve the same score as a particular variant of SimPLe. The red line indicates the 100K interactions threshold which is used by SimPLe.

Figure 9: (left) CDF of the number of iterations to acquire maximum score. The vertical axis represents the fraction of all games. (right) Comparison of random starts vs no random starts on Seaquest (for better readability we clip game rewards to {−1, 0, 1}). The vertical axis shows a mean reward and the horizontal axis the number of iterations of Algorithm 1.
18

Published as a conference paper at ICLR 2020
Figure 10: Frames from the Pong environment.
Figure 11: Frames from the Kung Fu Master environment (left) and its model (right). Another interesting example comes from Private Eye in which the agent traverses different scenes, teleporting from one to the other. We found that our model generally struggled to capture such large global changes.
19

Published as a conference paper at ICLR 2020

C ARCHITECTURE DETAILS

The world model is a crucial ingredient of our algorithm. Therefore the neural-network architecture of the model plays a crucial role. The high-level overview of the architecture is given in Section 4 and Figure 2. We stress that the model is general, not Atari speciﬁc, and we believe it could handle other visual prediction tasks. The whole model has around 74M parameters and the inference/backpropagation time is approx. 0.5s/0.7s respectively, where inference is on batch size 16 and backpropagation on batch size 2, running on NVIDIA Tesla P100. This gives us around 32ms per frame from our simulator, in comparison one step of the ALE simulator takes approximately 0.4ms.

Below we give more details of the architecture. First, the frame prediction network:

Layer Input frame dense Downscale convolution 1 Downscale convolution 2 Downscale convolution 3 Downscale convolution 4 Downscale convolution 5 Downscale convolution 6 Action embedding Latent predictor embedding Latent predictor LSTM Latent predictor output dense Reward predictor hidden Reward predictor output dense Middle convolution 1 Middle convolution 2 Upscale transposed convolution 1 Upscale transposed convolution 2 Upscale transposed convolution 3 Upscale transposed convolution 4 Upscale transposed convolution 5 Upscale transposed convolution 6 Output frame dense

Number of outputs 96 192 384 768 768 768 768 768 128 128 256 128 3 768 768 768 768 768 384 192 96 768

Other details -
kernel 4x4, stride 2x2 kernel 4x4, stride 2x2 kernel 4x4, stride 2x2 kernel 4x4, stride 2x2 kernel 4x4, stride 2x2 kernel 4x4, stride 2x2
kernel 3x3, stride 1x1 kernel 3x3, stride 1x1 kernel 4x4, stride 2x2 kernel 4x4, stride 2x2 kernel 4x4, stride 2x2 kernel 4x4, stride 2x2 kernel 4x4, stride 2x2 kernel 4x4, stride 2x2 -

The latent inference network, used just during training:

Layer

Number of outputs

Other details

Downscale convolution 1

128

kernel 8x8, stride 4x4

Downscale convolution 2

512

kernel 8x8, stride 4x4

All activation functions are ReLU, except for the layers marked as "output", which have softmax activations, and LSTM internal layers. In the frame prediction network, the downscale layers are connected to the corresponding upscale layers with residual connections. All convolution and transposed convolution layers are preceded by dropout 0.15 and followed by layer normalization. The latent predictor outputs 128 bits sequentially, in chunks of 8.

20

Published as a conference paper at ICLR 2020
D NUMERICAL RESULTS
Below we present numerical results of our experiments. We tested SimPLe on 7 conﬁgurations (see description in Section A). For each conﬁguration we run 5 experiments. For the evaluation of the i-th experiments we used the policy given by softmax(logits(πi)/T ), where πi is the ﬁnal learnt policy in the experiment and T is the temperature parameter. We found empirically that T = 0.5 worked best in most cases. A tentative explanation is that polices with temperatures smaller than 1 are less stochastic and thus more stable. However, going down to T = 0 proved to be detrimental in many cases as, possibly, it makes policies more prone to imperfections of models. In Table 2 we present the mean and standard deviation of the 5 experiments. We observed that the median behaves rather similarly, which is reported it in Table 4. In this table we also show maximal scores over 5 runs. Interestingly, in many cases they turned out to be much higher. This, we hope, indicates that our methods has a further potential of reaching these higher scores. Human scores are "Avg. Human" from Table 3 in Pohlen et al. (2018).
21

Published as a conference paper at ICLR 2020 22

Table 2: Models comparison. Mean scores and standard deviations over ﬁve training runs. Right most columns presents score for random agent and human.

Game

Ours, deterministic Ours, det. recurrent

Alien Amidar Assault Asterix Asteroids Atlantis BankHeist BattleZone BeamRider Bowling Boxing Breakout ChopperCommand CrazyClimber DemonAttack FishingDerby Freeway Frostbite Gopher Gravitar Hero IceHockey Jamesbond Kangaroo Krull KungFuMaster MsPacman NameThisGame Pong PrivateEye Qbert Riverraid RoadRunner Seaquest UpNDown YarsRevenge

378.3 62.4 361.4 668.0 743.7 14623.4 13.8 3306.2 463.8 25.3 -9.3 6.1 906.9 19380.0 191.9 -94.5 5.9 196.4 510.2 237.0 621.5 -12.6 68.8 481.9 834.9 10340.9 560.6 1512.1 -17.4 16.4 480.4 1285.6 5724.4 419.5 1329.3 3014.9

(85.5) (15.2) (166.6) (294.1) (92.2) (2122.5) (2.5) (794.1) (29.2) (10.4) (10.9) (2.8) (210.2) (6138.8) (86.3) (3.0) (13.1) (4.4) (158.4) (73.1) (1281.3) (2.1) (37.2) (313.2) (166.3) (8835.7) (172.2) (408.3) (5.2) (46.7) (158.8) (604.6) (3093.1) (236.2) (495.3) (397.4)

321.7 86.7 490.5 1853.0 821.7 12584.4 15.1 4665.6 358.9 22.3 -3.1 10.2 709.1 54700.3 120.3 -96.9 23.7 219.6 225.2 213.8 558.3 -14.0 100.5 191.9 1778.5 4086.6 1098.1 2007.9 -11.6 50.8 603.7 1740.7 1228.8 289.6 926.7 3291.4

(50.7) (18.8) (143.6) (391.8) (115.6) (5823.6) (2.2) (2799.4) (87.4) (17.0) (14.1) (5.1) (174.1) (14480.5) (38.3) (1.7) (13.5) (21.4) (105.7) (57.4) (1143.3) (1.8) (69.8) (301.0) (906.9) (3384.5) (450.9) (367.0) (15.9) (43.2) (150.3) (458.1) (1025.9) (110.4) (335.7) (1097.3)

Ours, SD long

616.9 74.3 527.2 1128.3 793.6 20992.5 34.2 4031.2 621.6 30.0 7.8 16.4 979.4 62583.6 208.1 -90.7 16.7 236.9 596.8 173.4 2656.6 -11.6 100.5 51.2 2204.8 14862.5 1480.0 2420.7 12.8 35.0 1288.8 1957.8 5640.6 683.3 3350.3 5664.3

(252.2) (28.3) (112.3) (211.8) (182.2) (11062.0) (29.2) (1156.1) (79.8) (5.8) (10.1) (6.2) (172.7) (16856.8) (56.8) (5.3) (15.7) (31.5) (183.5) (54.7) (483.1) (2.5) (36.8) (17.8) (776.5) (4031.6) (288.2) (289.4) (17.2) (60.2) (1677.9) (758.1) (3936.6) (171.2) (3540.0) (1870.5)

Ours, SD

Ours, SD γ = 0.90 Ours, SD γ = 0.95 Ours, SD 100 steps Ours, SD 25 steps random human

405.2 88.0 369.3 1089.5 731.0 14481.6
8.2 5184.4
422.7 34.4 9.1 12.7 1246.9 39827.8 169.5 -91.5 20.3 254.7 771.0 198.3 1295.1 -10.5 125.3 323.1 4539.9 17257.2 762.8 1990.4
5.2 58.3 559.8 1587.0 5169.4 370.9 2152.6 2980.2

(130.8) (23.8) (107.8) (335.3) (165.3) (2436.9) (4.4) (1347.5) (103.6) (16.3) (8.8) (3.8) (392.0) (22582.6) (41.8) (2.8) (18.5) (4.9) (160.2) (39.9) (1600.1) (2.2) (112.5) (359.8) (2470.4) (5502.6) (331.5) (284.7) (9.7) (45.4) (183.8) (818.0) (3939.0) (128.2) (1192.4) (778.6)

413.0 50.3 406.7 855.0 882.0 18444.1 11.9 2781.2 456.2 27.7 11.6
7.3 725.6 49840.9 187.5 -91.0 18.9 234.6 845.6 219.4 2853.9 -12.2 28.9 148.1 2396.5 12587.8 1197.1 2058.1
-2.9 54.4 899.3 1977.4 1586.2 364.6 1291.2 2934.2

(89.7) (11.7) (118.7) (176.4) (24.7) (4616.0) (2.5) (661.7) (160.8) (5.2) (12.6) (2.4) (204.2) (11920.9) (68.6) (4.1) (17.2) (26.8) (230.3) (7.8) (539.5) (2.9) (12.7) (121.5) (962.0) (6810.0) (544.6) (103.7) (7.3) (49.0) (474.3) (332.7) (1574.1) (138.6) (324.6) (459.2)

590.2 78.3
549.0 921.6 886.8 14055.6 12.0 4000.0 415.4
23.9 5.1 8.8 946.6 34353.1 194.9 -92.6 27.7 239.2 612.6 213.0 3503.5 -11.9 50.5 37.5 2620.9 16926.6 1273.3 2114.8 -2.5 67.8 1120.2 2115.1 8414.1 337.8 1250.6 3366.6

(57.8) (18.8) (127.9) (114.2) (45.2) (6226.1) (1.4) (788.9) (103.4) (3.3) (10.0) (5.1) (49.9) (33547.2) (89.6) (3.2) (13.3) (19.1) (273.9) (37.3) (892.9) (1.2) (21.3) (8.0) (856.2) (6598.3) (59.5) (387.4) (15.4) (26.4) (697.1) (106.2) (4542.8) (79.0) (493.0) (493.0)

435.6 37.7 311.7 777.0 821.9 14139.7 13.1 4068.8 456.0 29.3 -2.1 11.4 729.1 48651.2 170.1 -90.0 19.1 226.8 698.4 188.9 3052.7 -13.5 68.9 301.2 3559.0 17121.2 921.0 2067.2 -13.9 88.3 534.4 1318.7 722.2 247.8 1828.4 2673.7

(78.9) (15.1) (88.2) (200.4) (93.8) (2500.9) (3.2) (2912.1) (60.9) (7.5) (5.0) (3.7) (185.1) (14903.5) (42.4) (2.7) (16.7) (16.9) (213.9) (27.6) (169.3) (3.0) (42.7) (593.4) (1896.7) (7211.6) (306.0) (304.8) (7.7) (19.0) (162.5) (540.4) (627.2) (72.4) (688.3) (216.8)

534.8 82.2 664.5 1340.6 644.5 11641.2 12.7 3746.9 386.6 33.2 1.6
7.8 1047.2 25612.2
202.2 -94.5 27.3 252.1 509.7 116.4 1484.8 -13.9 163.4 340.0 3320.6 15541.2 805.8 1805.3 -1.0 1334.3 603.4 1426.0 4366.2 350.0 2136.5 4666.1

(166.2) (43.0) (298.2) (627.5) (110.6) (3385.0) (4.7) (1426.8) (264.4) (15.5) (14.7) (4.1) (221.6) (14037.5) (134.0) (2.5) (5.8) (54.4) (273.4) (84.0) (1671.7) (3.9) (81.8) (470.4) (2410.1) (5086.1) (261.1) (453.4) (14.9) (1794.5) (138.2) (374.0) (3867.8) (136.8) (2095.0) (1889.4)

184.8 11.8 233.7 248.8 649.0 16492.0 15.0 2895.0 372.1 24.2 0.3 0.9 671.0 7339.5 140.0 -93.6 0.0 74.0 245.9 227.2 224.6 -9.7 29.2 42.0 1543.3 616.5 235.2 2136.8 -20.4 26.6 166.1 1451.0 0.0 61.1 488.4 3121.2

7128.0 1720.0 742.0 8503.0 47389.0 29028.0 753.0 37188.0 16926.0 161.0 12.0
30.0 7388.0 35829.0 1971.0 -39.0 30.0
2412.0 3351.0 30826.0
1.0 303.0 3035.0 2666.0 22736.0 6952.0 8049.0 15.0 69571.0 13455.0 17118.0 7845.0 42055.0 11693.0 54577.0

Published as a conference paper at ICLR 2020 23

Table 3: Comparison of our method (SimPLe) with model-free benchmarks - PPO and Rainbow, trained with 100 thousands/500 thousands/1 million steps. (1 step equals 4 frames)

Game
Alien Amidar Assault Asterix Asteroids Atlantis BankHeist BattleZone BeamRider Bowling Boxing Breakout ChopperCommand CrazyClimber DemonAttack FishingDerby Freeway Frostbite Gopher Gravitar Hero IceHockey Jamesbond Kangaroo Krull KungFuMaster MsPacman NameThisGame Pong PrivateEye Qbert Riverraid RoadRunner Seaquest UpNDown YarsRevenge

SimPLe

616.9 74.3 527.2 1128.3 793.6 20992.5 34.2 4031.2 621.6 30.0 7.8 16.4 979.4 62583.6 208.1 -90.7 16.7 236.9 596.8 173.4 2656.6 -11.6 100.5 51.2 2204.8 14862.5 1480.0 2420.7 12.8 35.0 1288.8 1957.8 5640.6 683.3 3350.3 5664.3

(252.2) (28.3) (112.3) (211.8) (182.2) (11062.0) (29.2) (1156.1) (79.8) (5.8) (10.1) (6.2) (172.7) (16856.8) (56.8) (5.3) (15.7) (31.5) (183.5) (54.7) (483.1) (2.5) (36.8) (17.8) (776.5) (4031.6) (288.2) (289.4) (17.2) (60.2) (1677.9) (758.1) (3936.6) (171.2) (3540.0) (1870.5)

PPO_100k

291.0 56.5 424.2 385.0 1134.0 34316.7 16.0 5300.0 563.6 17.7 -3.9 5.9 730.0 18400.0 192.5 -95.6 8.0 174.0 246.0 235.0 569.0 -10.0 65.0 140.0 3750.4 4820.0 496.0 2225.0 -20.5 10.0 362.5 1398.0 1430.0 370.0 2874.0 5182.0

(40.3) (20.8) (55.8) (104.4) (326.9) (5703.8) (12.4) (3655.1) (189.4) (11.2) (6.4) (3.3) (199.0) (5275.1) (83.1) (4.3) (9.8) (40.7) (103.3) (197.2) (1100.9) (2.1) (46.4) (102.0) (3071.9) (983.2) (379.8) (423.7) (0.6) (20.0) (117.8) (513.8) (760.0) (103.3) (1105.8) (1209.3)

PPO_500k

269.0 93.2 552.3 1085.0 1053.0 4836416.7 641.0 14400.0 497.6 28.5 3.5 66.1 860.0 33420.0 216.5 -87.2 14.0 214.0 560.0 235.0 1824.0 -6.6 255.0 340.0 3056.1 17370.0 306.0 2106.0 -8.6 20.0 757.5 2865.0 5750.0 692.0 12126.0 8064.8

(203.4) (36.7) (110.4) (354.8) (433.3) (6218247.3) (352.8) (6476.1) (103.5) (3.4) (3.5) (114.3) (285.3) (3628.3) (96.2) (5.3) (11.5) (10.2) (118.8) (134.7) (1461.2) (1.6) (101.7) (407.9) (1155.5) (10707.6) (70.2) (898.8) (14.9) (40.0) (78.9) (327.1) (5259.9) (48.3) (1389.5) (2859.8)

PPO_1m

362.0 123.8 1134.4 2185.0 1251.0
856.0 19000.0 684.0 35.8 19.6 128.0 970.0 58000.0 241.0 -88.8 20.8 229.0 696.0 325.0 3719.0
-5.3 310.0 840.0 5061.8 13780.0 594.0 2311.0 14.7 20.0 2675.0 2887.0 8930.0 882.0 13777.0 9495.0

(102.0) (19.7) (798.8) (931.6) (377.9) (-) (376.7) (4571.7) (168.8) (6.2) (20.9) (153.3) (201.5) (16994.6) (135.0) (4.0) (11.1) (20.6) (279.3) (85.1) (1306.0) (1.7) (129.0) (806.5) (1333.4) (3971.6) (247.9) (547.6) (5.1) (40.0) (1701.1) (807.0) (4304.0) (122.7) (6766.3) (2638.3)

Rainbow_100k

290.6 20.8 300.3 285.7 912.3 17881.8 34.5 3363.5 365.6 24.7 0.9 3.3 776.6 12558.3 431.6 -91.1 0.1 140.1 748.3 231.4 2676.3 -9.5 61.7 38.7 2978.8 1019.4 364.3 2368.2 -19.5 42.1 235.6 1904.2 524.1 206.3 1346.3 3649.0

(14.8) (2.3) (14.6) (9.3) (62.7) (617.6) (2.0) (523.8) (29.8) (0.8) (1.7) (0.1) (59.0) (674.6) (79.5) (2.1) (0.1) (2.7) (105.4) (50.7) (93.7) (0.8) (8.8) (9.3) (148.4) (149.6) (20.4) (318.3) (0.2) (53.8) (12.9) (44.2) (147.5) (17.1) (95.1) (168.6)

Rainbow_500k

828.6 194.0 1041.5 1702.7 895.9 79541.0 727.3 19507.1 5890.0 31.0 58.2 26.7 1765.2 75655.1 3642.1 -66.7 12.6 1386.1 1640.5 214.9 10664.3
-9.7 429.7 970.9 4139.4 19346.1 1558.0 4886.5 19.9
-6.2 4241.7 5068.6 18415.4 1558.7 6120.7 7005.7

(54.2) (34.9) (92.1) (162.8) (82.0) (25393.4) (198.3) (3193.3) (525.6) (1.9) (16.5) (2.4) (280.7) (9439.6) (478.2) (6.0) (15.4) (321.7) (105.6) (27.6) (1060.5) (0.8) (27.9) (501.9) (336.2) (3274.4) (248.9) (583.1) (0.4) (89.8) (193.1) (292.6) (5280.0) (221.2) (356.8) (394.2)

Rainbow_1m

945.0 275.8 1581.8 2151.6 1071.5 848800.0 1053.3 22391.4 6945.3 30.6 80.3 38.7 2474.0 97088.1 5478.6 -23.2 13.0 2972.3 1905.0 260.0 13295.5
-6.5 692.6 4084.6 4971.1 21258.6 1881.4 4454.2 20.6 2336.7 8885.2 7018.9 31379.7 3279.9 8010.9 8225.1

(85.0) (66.7) (207.8) (202.6) (91.7) (37533.1) (22.9) (7708.9) (1390.8) (6.2) (5.6) (3.4) (504.5) (9975.4) (297.9) (22.3) (15.9) (284.9) (211.1) (22.7) (261.2) (0.5) (316.2) (1954.1) (360.3) (3210.2) (112.0) (338.3) (0.2) (4732.6) (1690.9) (334.2) (3225.8) (683.9) (907.0) (957.9)

random
184.8 11.8 233.7 248.8 649.0 16492.0 15.0 2895.0 372.1 24.2 0.3 0.9 671.0 7339.5 140.0 -93.6 0.0 74.0 245.9 227.2 224.6 -9.7 29.2 42.0 1543.3 616.5 235.2 2136.8 -20.4 26.6 166.1 1451.0 0.0 61.1 488.4 3121.2

human
7128.0 1720.0 742.0 8503.0 47389.0 29028.0 753.0 37188.0 16926.0 161.0 12.0 30.0 7388.0 35829.0 1971.0 -39.0
30.0 -
2412.0 3351.0 30826.0
1.0 303.0 3035.0 2666.0 22736.0 6952.0 8049.0 15.0 69571.0 13455.0 17118.0 7845.0 42055.0 11693.0 54577.0

Published as a conference paper at ICLR 2020 24

Table 4: Models comparison. Scores of median (left) and best (right) models out of ﬁve training runs. Right most columns presents score for random agent and human.

Game
Alien Amidar Assault Asterix Asteroids Atlantis BankHeist BattleZone BeamRider Bowling Boxing Breakout ChopperCommand CrazyClimber DemonAttack FishingDerby Freeway Frostbite Gopher Gravitar Hero IceHockey Jamesbond Kangaroo Krull KungFuMaster MsPacman NameThisGame Pong PrivateEye Qbert Riverraid RoadRunner Seaquest UpNDown YarsRevenge

Ours, deterministic

354.4 58.0 334.4 529.7 727.3 15587.5 14.4 3312.5 453.1 27.0 -7.1 5.5 942.2 20754.7 219.2 -94.3
0.0 194.5 514.7 232.8 71.5 -12.4 64.8 500.0 852.2 7575.0 557.3 1468.1 -19.6
0.0 476.6 1416.1 5901.6 414.4 1195.9 3047.0

516.6 84.8 560.1 1087.5 854.7 16545.3 16.2 4140.6 515.5 36.2 0.2 9.8 1167.2 23831.2 263.0 -90.2 29.3 203.9 740.6 310.2 2913.0 -9.9 128.9 828.1 1014.3 20450.0 818.0 1992.7 -8.5 98.9 702.7 1929.4 8484.4 768.1 2071.1 3380.5

Ours, det. recurrent

299.2 82.7 566.6 1798.4 827.7 15939.1 14.7 4515.6 351.4 28.4 3.5 12.5 748.4 49854.7 135.8 -97.3 29.3 213.4 270.3 219.5 75.0 -14.8 64.8 68.8 1783.6 4848.4 1178.8 1826.7 -17.3 75.0 555.9 1784.4 781.2 236.9 1007.5 3416.3

381.1 118.4 627.2 2282.0 919.8 17778.1 18.8 9312.5 470.2 43.7 5.0 13.9 957.8 80156.2 148.4 -94.2 32.2 256.2 320.9 300.0 2601.5 -11.8 219.5 728.1 2943.6 8065.6 1685.9 2614.5 16.7 82.8 869.9 2274.5 2857.8 470.6 1315.2 4230.8

Ours, SD long

515.9 80.2 509.1 1065.6 899.7 13695.3 31.9 3484.4 580.2 28.0 9.4 16.0 909.4 55795.3 191.2 -91.8 21.5 248.8 525.3 156.2 2935.0 -12.3 110.9 62.5 1933.7 14318.8 1525.0 2460.0 20.7 0.0 656.2 2360.0 5906.2 711.6 1616.1 6580.2

1030.5 102.7 671.1 1485.2 955.6 34890.6 77.5 5359.4 728.8 39.6 21.0 22.8 1279.7 87593.8 288.9 -84.3 32.0 266.9 845.6 233.6 3061.6 -7.2 141.4 65.6 3317.5 21054.7 1903.4 2782.8 21.0 100.0 4259.0 2659.8 11176.6 854.1 8614.5 7547.4

Ours, SD

409.2 85.1 355.7 1158.6 671.2 13645.3 8.9 5390.6 433.9 24.9 8.3 11.0 1139.1 41396.9 182.4 -91.6 33.5 253.1 856.9 202.3 237.5 -10.0 87.5 215.6 4264.3 17448.4 751.2 1919.8 1.4 76.6 508.6 1799.4 2804.7 386.9 2389.5 2435.5

586.9 114.0 527.9 1393.8 962.0 18396.9 13.9 7093.8 512.6 55.0 21.5 19.5 1909.4 67250.0 223.9 -88.6 34.0 262.8 934.4 252.3 3133.8 -7.7 323.4 909.4 7163.2 21943.8 1146.1 2377.7 21.0 100.0 802.7 2158.4 10676.6 497.2 3798.3 3914.1

Ours, SD γ = 0.90

411.9 55.1 369.1 805.5 885.5 19367.2 12.3 2937.5 393.5 27.7 6.4 7.4 682.8 56875.0 160.3 -90.0 31.1 246.7 874.1 223.4 3135.0 -11.8 25.0 103.1 1874.8 12964.1 1410.5 2087.3 -2.0 75.0 802.3 2053.8 1620.3 330.9 1433.3 2955.9

530.5 58.9 614.4 1159.4 909.1 23046.9 14.5 3343.8 682.8 34.9 31.5 10.4 1045.3 58979.7 293.8 -85.7 32.0 261.7 1167.2 225.8 3147.5 -8.5 46.9 334.4 3554.5 21956.2 1538.9 2155.2 6.6 96.9 1721.9 2307.5 4104.7 551.2 1622.0 3314.5

Ours, SD γ = 0.95

567.3 84.3 508.4 923.4 886.1 12981.2 12.3 4421.9 446.6 22.6 2.5 10.2 954.7 19448.4 204.1 -92.0 33.5 250.0 604.1 228.1 3066.2 -11.6 58.6 34.4 2254.0 20195.3 1277.3 1994.8 3.8 60.9 974.6 2143.6 7032.8 332.8 1248.6 3434.8

682.7 101.4 722.5 1034.4 949.5 23579.7 13.1 4703.1 519.2 28.6 15.0 14.1 1010.9 84070.3 312.8 -88.8 33.8 255.9 1001.6 243.8 5092.0 -10.7 69.5 50.0 3827.1 23690.6 1354.5 2570.3 14.2 100.0 2322.3 2221.2 14978.1 460.9 1999.4 3896.3

SD 100 steps

399.5 45.2 322.9 813.3 813.8 15020.3 12.8 3500.0 447.1 28.4 -0.7 10.5 751.6 53406.2 164.4 -90.6 30.0 215.8 726.9 193.8 3067.3 -12.9 61.7 43.8 3142.8 19718.8 866.2 2153.4 -17.9 96.9 475.0 1387.8 857.8 274.1 1670.3 2745.3

522.3 47.5 391.1 1000.0 962.2 16790.6 17.2 8906.2 544.6 39.9 2.2 16.7 989.1 64196.9 222.6 -85.4 32.3 247.7 891.6 218.0 3256.9 -10.0 139.1 1362.5 6315.2 25375.0 1401.9 2471.9 -2.0 99.3 812.5 1759.8 1342.2 317.2 2728.0 2848.1

Ours, SD 25 steps

525.5 93.1 701.4 1128.1 657.5 12196.9 14.1 3859.4 385.7 37.0 -0.9
6.9 1031.2 19345.3
187.5 -95.0 29.9 249.4 526.2 93.0 1487.2 -12.2 139.8 56.2 3198.2 18025.0 777.2 1964.2 -10.1 100.0 668.8 1345.5 2717.2 366.9 1825.2 4276.3

792.8 137.7 1060.3 2313.3 752.7 15728.1 17.0 5734.4 741.9 54.7 20.8 13.0 1329.7 43179.7 424.8 -90.7 33.5 337.5 845.0 240.6 2964.8 -11.0 261.7 1128.1 6833.4 20365.6 1227.8 2314.8 21.0 4038.7 747.3 1923.4 8560.9 527.2 5193.1 6673.1

random
184.8 11.8 233.7 248.8 649.0 16492.0 15.0 2895.0 372.1 24.2 0.3 0.9 671.0 7339.5 140.0 -93.6 0.0 74.0 245.9 227.2 224.6 -9.7 29.2 42.0 1543.3 616.5 235.2 2136.8 -20.4 26.6 166.1 1451.0 0.0 61.1 488.4 3121.2

human
7128.0 1720.0 742.0 8503.0 47389.0 29028.0 753.0 37188.0 16926.0 161.0 12.0 30.0 7388.0 35829.0 1971.0 -39.0 30.0
2412.0 3351.0 30826.0
1.0 303.0 3035.0 2666.0 22736.0 6952.0 8049.0 15.0 69571.0 13455.0 17118.0 7845.0 42055.0 11693.0 54577.0

Published as a conference paper at ICLR 2020
E BASELINES OPTIMIZATION
To assess the performance of SimPle we compare it with model-free algorithms. To make this comparison more reliable we tuned Rainbow in the low data regime. To this end we run an hyperparameter search over the following parameters from https://github.com/google/dopamine/ blob/master/dopamine/agents/rainbow/rainbow_agent.py:
• update_horizon in {1, 3}, best parameter = 3 • min_replay_history in {500, 5000, 20000}, best parameter = 20000 • update_period in {1, 4}, best parameter = 4 • target_update_period {50, 100, 1000, 4000}, best parameter = 8000 • replay_scheme in {uniform, prioritized}, best parameter = prioritized Each set of hyperparameters was used to train 5 Rainbow agents on the game of Pong until 1 million of interactions with the environment. Their average performance was used to pick the best hyperparameter set. For PPO we used the standard set of hyperparameters from https://github.com/openai/ baselines.
F RESULTS AT DIFFERENT NUMBERS OF INTERACTIONS
25

Published as a conference paper at ICLR 2020

(a) Fraction at 100K clipped to 10.

(b) Fraction at 200K

(c) Fraction at 500K.

(d) Fraction at 1M.

Figure 12: Fractions of the rainbow scores at given number of samples. These were calculate with the formula (SimP Le_score − random_score)/(rainbow_score − random_score); if denominator is smaller than 0, both nominator and denominator are increased by 1.
26

Published as a conference paper at ICLR 2020

(a) Fraction at 100K clipped to 10.

(b) Fraction at 200K

(c) Fraction at 500K.

(d) Fraction at 1M.

Figure 13: Fractions of the ppo scores at given number of samples. These were calculate with the formula (SimP Le_score − random_score)/(ppo_score − random_score); if denominator is smaller than 0, both nominator and denominator are increased by 1.
27

Published as a conference paper at ICLR 2020

(a) SimPLe compared to Rainbow at 100K.

(b) SimPLe compared to Rainbow at 200K

(c) SimPLe compared to PPO at 100K.

(d) SimPLe compared to PPO at 200K.

Figure 14: Comparison of scores from Simple against Rainbow and PPO at different numbers of interactions. The following formula is used: (SimP Le_score@100K − baseline_score)/human_score. Points are normalized by average human score in order to be presentable in one graph.
28

